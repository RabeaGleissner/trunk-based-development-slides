<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/dracula.css">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown data-separator-vertical="^--$">
        <script type="text/template">
            ## Committing to main
            What I learnt from doing trunk based development ğŸ˜

            And how it can help you, too! âœ¨

            Note: With this talk I'd like to encourage teams to try this practise as well...
            Or at least adopt some of the ways of working that I've learnt from this because I think it's beneficial.
            ---
            ## What I'll cover in this presentation

            1. What is trunk based development?
            1. Two stories about my own experience
            1. Reflection time
            1. Why is it great?
            1. What practises we can adopt now
            ---
            ## 1. What is trunk based development?

            - every developer makes small commits to main
            - every commit is deployed directly to production
            - ğŸš« no branches

            Note: It's a development practise where every there are no branches. Every developer in the team commits straight to the main branch, which is also sometimes called "trunk", hence the name.
            ---
            ## Audience participation, please!

            Note: Ok, before I get deeper into this talk, I'd like to ask for some audience participation, please.
            --
            <div class="chapter-title">Audience participation</div>

            ## Who is practising continous integration? âœ‹

            Note: Please raise your hand on Teams if your team practises continous integration.
            --
            <div class="chapter-title">Audience participation</div>

            ## Who is practising trunk based development? âœ‹

            Note: And now, please raise your hand on Teams if your team practises trunk based development in the way that I described it.
            --
            ## But is your integration really continous if you don't commit to main? ğŸ¤¯
            ---
            ## Does this not result in chaos?
            - well, sometimes <!-- .element: class="fragment" -->
            - you have to learn it <!-- .element: class="fragment" -->
            - you have to have the right safety net in place <!-- .element: class="fragment" -->

            â¡ï¸ some of the best practises can help every team <!-- .element: class="fragment" -->

            Note: So you might be wondering to yourself... does this trunk based business not result in total chaos?
            You have to follow certain practises in order to do it... and I think those practises are useful for any team, no matter if you're using feature branches or trunk based at scale or you commit to main.
            ---
            # 2. Story time
            --
            <div class="chapter-title">Story time</div>

            ### How it started...
            - ğŸ‘¨ğŸ¼â€ğŸ’» ğŸ‘©ğŸ¼â€ğŸ’» ğŸ‘©ğŸ»â€ğŸ’» <!-- .element: class="fragment" -->
            - ğŸ£ ğŸ“ <!-- .element: class="fragment" -->

            Note: back in the day, Danny, Sarah and I were working on an automated underwriting system for a large insurance company.
            --
            <div class="chapter-title">Story time (1/2)</div>

            ### Disclaimer
            Names, places and incidents are all products of the author's imagination.

            Or are they? ğŸ•µğŸ»â€â™‚ï¸
            --
            <div class="chapter-title">Story time (1/2)</div>

            ### How it started...
            - ğŸ‘¨ğŸ¼â€ğŸ’» ğŸ‘©ğŸ¼â€ğŸ’» ğŸ‘©ğŸ»â€ğŸ’» 
            - ğŸ£ ğŸ“ 
            - medium sized code base (Ruby)
            - we'd been working with feature branches & PRs <!-- .element: class="fragment" -->
            - pair programming most of the time <!-- .element: class="fragment" -->
            - very strict TDD <!-- .element: class="fragment" -->
            - releases were infrequently done by the client <!-- .element: class="fragment" -->
            - ğŸ™‹ğŸ¼â€â™‚ï¸: "Let's commit to main!" <!-- .element: class="fragment" -->

            Note: back in the day, Danny, Sarah and I were working on an automated underwriting system for a large insurance company.
            --
            <div class="chapter-title">Story time (1/2)</div>

            ## How it went...
            - a bit of a mess
            - we made huge commits
            - we waited sometimes for days to push to main
            - ğŸ™‹ğŸ¼â€â™‚ would make huge refactorings in the evening
            - `git pull` always resulted in conflicts
            - it was painful
            --
            <div class="chapter-title">Story time (2/2)</div>

            ## How it started...
            - ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ğŸ‘ªğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ <!-- .element: class="fragment" -->
            - ğŸ¡ğŸ–¥ï¸ <!-- .element: class="fragment" -->
            - started a new codebase (React) <!-- .element: class="fragment" -->
            - distributed team Melbourne â†”ï¸ US West coast <!-- .element: class="fragment" -->
            - synchronous overlap: 1 hour a day <!-- .element: class="fragment" -->
            - how else would you work? ğŸ¤·ğŸ»â€â™‚ï¸ <!-- .element: class="fragment" -->

            Note: There were a couple of people in our team (including me!!) who pushed for using short-lived feature branches.
            After my first experienced with trunk based development I didn't really fancy doing it again. I especially thought that it will be hard to work async with the American team.
            --
            <div class="chapter-title">Story time (2/2)</div>

            ## How we worked ğŸ¦˜
            - always pair-program <!-- .element: class="fragment" -->
            - strict TDD <!-- .element: class="fragment" -->
            - every commit automatically released to production <!-- .element: class="fragment" -->
            - build notifications in Slack -> if red, fix immediately <!-- .element: class="fragment" -->
            - push small commits continuously <!-- .element: class="fragment" -->
            - run the full build locally before each commit <!-- .element: class="fragment" -->

            Note: It wasn't possible to pair-program 100% because we sometimes were an uneven number of devs. So we had this alternative where one person could work solo but would need to have a sync call with someone to go through the changes in the commit.
            We didn't use feature flags.
            --
            <div class="chapter-title">Story time (2/2)</div>

            ## How it went...
            - we made really good progress
            - code quality was generally high
            - hardly any merge conflicts
            - everyone knew how all the features worked
            - trunk based can work!
            ---
            # 3. Reflection time
            --
            ## Why was my second experience much better than the first?

            Note: Both times we fulfilled the two important pre-requesits, which is having a strong test suite and pair-programming.
            --
            ### The important difference:

            We didn't wait...

            Note: To be fair, my first experience with TBD was 6 or 7 years ago and I don't remember all the details.
            But back then we didn't manage to make our commits small enough to be able to push them straight away.
            We also didn't pull the code often enough for fear of merge conflicts... "let's finish our code first and then we deal with the merge conflicts". It can't work like that.
            It requires a different way of approaching your coding. 
            ---
            ## How to make it work

            You have to change your development approach a bit...
            --
            <div class="chapter-title">How to make it work...</div>

            ## It's ok to have unused code

            Note: But don't comment out code... you want to know that your tests always pass and your unused code can be integrated with the rest of the codebase
            --
            <div class="chapter-title">How to make it work...</div>

            ### Build your components in isolation first

            Note: If it's front-end code, maybe build the component separately first, for example in Storybook and when it's ready, then integrate it into your page. You can do the same with backend code... start building some data retrieval and transformation logic... later the API and only actually use it when it's done.
            --
            <div class="chapter-title">How to make it work...</div>

            ### Split out any refactoring

            Note: If you start working on a feature and realise that you need to do some refactoring, do that first and separately. 
            --
            <div class="chapter-title">How to make it work...</div>

            ### Hide your code behind a feature flag

            Note: that also makes it easy to test in production
            --
            <div class="chapter-title">How to make it work...</div>

            ### Use the "branch by abstraction" technique

            Note: Yes, I said there are no branches... this isn't a real branch. If you need to make a change to an existing component, the idea is that you first create an abstraction layer for it. And change all client code that depends on the component, to depend on the abstraction layer instead. Then write a second implementation for this abstraction layer and when that's all working correctly, switch over the second implementation for the first. You can even keep the abstraction as it might help you with your unit tests if you have this additional seam.

            There's a blog post by Martin Fowler about this who can explain this much better than me.
            --
            <div class="chapter-title">How to make it work...</div>

            ### Commit as soon as possible

            Note: When is that? As soon as you completed the red-green-refactor cycle of TDD. Never commit when the tests are failing
            --
            <div class="chapter-title">How to make it work...</div>

            ### Communicate a lot more

            Note: The team needs to work together much more closely. Everyone needs to know what others are working on so they really understand the changes they're pulling down, how their own code fits with those... you can't rely on a short explanation in a PR, quick review... yeah, I kind of get it... no, everyone in the team really needs to understand what's going on.

            In a way you also need to communicate less because your latest code will always be visible to all other engineers.
            ---
            ## Is it better than using short-lived feature branches?

            Note: The experiment worked... but was it worth the effort of changing the way we worked and approached a feature?
            --
            # Yes

            Note: and that is the end of my talk
            ---
            # 4. Why is it better?

            Note: joking, I'll tell you why I think it was a really great way of working.
            --
            <div class="chapter-title">Why is it better?</div>

            ### Code is always in a releasable state

            Note: There's never any... "is everyone ready for a release? Oh no, wait, give me half an hour, I need to fix this..." If you want to get your code into prod, just do it!
            --
            <div class="chapter-title">Why is it better?</div>

            ### You don't need to wait for a PR review

            Note: It's not just the PR review and possibly approval, it's also suggestion for changes, asking for clarification etc... it all takes time. You raise the PR, you switch context to work on another thing... 
            --
            <div class="chapter-title">Why is it better?</div>

            ### You move faster

            Note: and as a result of that, I'm convinced that you do move faster as a team.
            --
            <div class="chapter-title">Why is it better?</div>

            ### You get into the habit of not breaking things

            Note: Mentally, it's just different if you know that your code will go live immediately. You are way more careful, more sharp. And when the build is red, it's serious. We'd address it straight away.
            --
            <div class="chapter-title">Why is it better?</div>

            ### Reviewing code changes is much easier

            Note: when you pull the code down to get the latest changes, it's much easier to review them. You're in your IDE, you're in the context of your code... many times I've actually pulled down the branch to review a PR to see the context in which the code runs.
            --
            <div class="chapter-title">Why is it better?</div>

            ### Full commit history is retained

            Note: You can really follow the history of the codebase much more naturally. There are no merge commits... no squashes... 
            --
            <div class="chapter-title">Why is it better?</div>

            ### Collective code ownership and knowledge

            Note: Everyone felt a lot more ownership over the code. You don't have the feeling of "someone else built this, I don't know what their thinking was... let me ask this person but they're not working today...". Everyone knew much more about the codebase, why things were the way they were etc.
            --
            <div class="chapter-title">Why is it better?</div>

            ### You don't need a staging environment ğŸ¤·ğŸ»â€â™€ï¸

            Note: Save some money, save the hassle of keeping the staging content / data up to date and realistic...
            --
            ### Couple of caveats

            - I've only tried this with codebases under active development <!-- .element: class="fragment" -->
            - One downside: harder to revert a feature <!-- .element: class="fragment" -->

            Note: I would be remiss if I didn't mention some small caveats... Nothing is always 100% positive.
            ---
            ## Convinced yet?
            ---
            ## 5. How do you start?

            Note: So do you fancy trying it out as a team?
            --
            ### Start slowly

            - small codebase
            - you have to have confidence in your tests
            - you have to pair-program

            Note: I wouldn't recommend going all in straight away. Maybe start with a new codebase or a small codebase.
            --
            ### Even if your team process and codebase is not there yet...

            Note: I know that most teams probably don't pair-program that much and most codebases don't have super reliable tests.
            --
            ### How about you start with...
            --
            <div class="chapter-title">Start with...</div>

            ## Raising small PRs

            Note: Make your PRs a bit smaller... it doesn't have to be one feature per PR. Advantage of a small PR is that the review will be much quicker, you get it merged in quicker, releases are less risky...
            --
            <div class="chapter-title">Start with...</div>

            ## Removing the mandatory PR approvals

            Note: I don't mean, just merge in all PRs as you want... but you could agree as a team that you ask for feedback if you want some... or you could just inform people, hey, I made this change, I'll merge it in now... or if it's a small change, just merge it in.
            --
            <div class="chapter-title">Start with...</div>

            ## Agreeing to pair on a small feature and push a commit to main

            Note: just try it out with a small feature... maybe you'll enjoy pairing on something. Just push it to main.
            --
            <div class="chapter-title">Start with...</div>

            ## Deploying all commits on main into staging

            Note: As a first step you don't need to make all commits go to prod straight away but you could let them go to staging instead.
            ---
            ## Audience participation again, please!

            Note: Before I finish this talk and open up for questions...
            --
            ## Do you think that you can adopt some new practises in your team? âœ‹

            Note: Please raise your hand if you think you can start adopting some of the practises in your team.
            ---
            # Any questions?

            Thank you for listening ğŸ˜
          </script>
      </section>
    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>