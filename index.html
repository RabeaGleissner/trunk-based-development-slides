<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="dist/theme/dracula.css">

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section data-markdown data-separator-vertical="^--$">
        <script type="text/template">
            ## Committing to main
            What I learnt from doing trunk based development 🐘

            And how it can help you, too! ✨

            Note: With this talk I'd like to encourage teams to try this practise as well...
            Or at least adopt some of the ways of working that I've learnt from this because I think it's beneficial.
            ---
            ## What I'll cover in this presentation

            1. What is trunk based development?
            1. Two stories about my own experience
            1. Reflection time
            1. What practises we can adopt
            ---
            ## What is trunk based development?
            - every developer makes small commits to main <!-- .element: class="fragment" -->
            - every commit is deployed directly to production <!-- .element: class="fragment" -->
            - 🚫 no branches <!-- .element: class="fragment" -->
            ---
            <!-- vertical slides -->
            ## Audience participation, please!
            --
            ## Who is practising continous integration? ✋
            --
            ## Who is practising trunk based development? ✋
            --
            ## But is your integration really continous if you don't commit to main? 🤯
            ---
            ## Does this not result in chaos?
            - well, sometimes <!-- .element: class="fragment" -->
            - you have to learn it <!-- .element: class="fragment" -->
            - you have to have the right safety net in place <!-- .element: class="fragment" -->

            ➡️ but some of the best practises can help every team <!-- .element: class="fragment" -->

            Note: So you might be wondering to yourself... does this trunk based business not result in total chaos?
            You have to follow certain practises in order to do it... and I think those practises are useful for any team, no matter if you're using feature branches or trunk based at scale or you commit to main.
            ---
            # Story time
            ---
            ## What I'll cover in this presentation

            1. What is trunk based development?
            1. ➡️  ➡️  Two stories about my own experience ⬅️  ⬅️
            1. Reflection on what could have gone better
            1. What practises we can adopt in our"short lived feature branch" environment
            ---
            ## Let me tell you about the time...
            - 👨🏼‍💻 👩🏼‍💻 👩🏻‍💻 <!-- .element: class="fragment" -->
            - 🏣 📝 <!-- .element: class="fragment" -->
            - medium sized code base (Ruby) <!-- .element: class="fragment" -->
            - we'd been working with feature branches & PRs <!-- .element: class="fragment" -->
            - pair programming most of the time <!-- .element: class="fragment" -->
            - very strict TDD <!-- .element: class="fragment" -->
            - releases were infrequently done by the client <!-- .element: class="fragment" -->
            - no feature flags <!-- .element: class="fragment" -->
            - 🙋🏼‍♂️: "Let's commit to main!" <!-- .element: class="fragment" -->

            Note: back in the day, Danny, Sarah and I were working on an automated underwriting system for a large insurance company.
            ---
            ### Disclaimer
            Names, characters, places and incidents either are products of the author's imagination or are used fictitiously.

            Or are they?????
            ---
            ## The result
            - a bit of a mess
            - we made huge commits
            - we waited sometimes for days to push to main
            - 🙋🏼‍ would make huge refactorings in the evening
            - git pull always resulted in conflicts
            - it was painful
            ---
            ## Let me tell you about the other time...
            - 👨‍👩‍👦‍👦👪👨‍👨‍👦 
            - 🏡🖥️
            - started a new codebase (React)
            - distributed team Melbourne ↔️ US West coast
            - synchronous overlap: 1 hour a day
            - how else would you work? 🤷🏻‍♂️

            Note: There were a couple of people in our team (including me!!) who pushed for using short-lived feature branches.
            After my first experienced with trunk based development I didn't really fancy doing it again. I especially thought that it will be hard to work async with the American team.
            ---
            ## The process 🦘
            - always pair-program
            - strict TDD
            - every commit automatically released to production
            - build notifications in Slack -> if red, fix immediately
            - push small commits continuously
            - run the full build locally before each commit

            Note: It wasn't possible to pair-program 100% because we sometimes were an uneven number of devs. So we had this alternative where one person could work solo but would need to have a sync call with someone to go through the changes in the commit.
            We didn't use feature flags.
            ---
            ## The result
            - we made really good progress
            - code quality was generally high
            - hardly any merge conflicts
            - everyone knew how all the features worked
            - trunk based can work!
            ---
            1. What is trunk based development?
            1. Two stories about my own experience
            1. ➡️  ➡️  Reflection time ⬅️  ⬅️
            1. What practises we can adopt in our"short lived feature branch" environment
            ---
            # Reflection time
            ---
            ## Why was my second experience much better than the first?

            Note: Both times we fulfilled the two important pre-requesits, which is having a strong test suite and pair-programming.

            ---
            ### The important difference:

            We didn't wait...

            Note: To be fair, my first experience with TBD was 6 or 7 years ago and I don't remember all the details.
            But back then we didn't manage to make our commits small enough to be able to push them straight away.
            We also didn't pull the code often enough for fear of merge conflicts... "let's finish our code first and then we deal with the merge conflicts". It can't work like that.
            It requires a different way of approaching your coding. 
            ---
            ## You have to change your development approach
            ---
            ## It's ok to have unused code

            Note: But don't comment out code... you want to know that your tests always pass and your unused code can be integrated with the rest of the codebase
            --
            ### Build your components with Storybook

            Note: If it's front-end code, maybe build the component separately first and when it's ready, then integrate it into your page.
            --
            ### Split out any refactoring

            Note: If you start working on a feature and realise that you need to do some refactoring, do that first and separately. 
            --
            ### Hide your code behind a feature flag

            Note: that also makes it easy to test in production
            --
            ### Use the "branch by abstraction" technique

            Note: TODO - explain what that is
            --
            ### Commit as soon as possible

            Note: When is that? As soon as you completed the red-green-refactor cycle of TDD. Never commit when the tests are failing
            --
            ### Communicate a lot more

            Note: The team needs to work together much more closely. Everyone needs to know what others are working on so they really understand the changes they're pulling down, how their own code fits with those... you can't rely on a short explanation in a PR, quick review... yeah, I kind of get it... no, everyone in the team really needs to understand what's going on
            ---
            ## Was it better than using short-lived feature branches?

            Note: The experiment worked... but was it worth the effort of changing the way we worked and approached a feature?
            ---
            # Yes

            Note: and that is the end of my talk
            --
            # Why?

            Note: joking, I'll tell you why I think it was great
            --
            ### Code is always in a releasable state

            Note: There's never any... is everyone ready for a release? Oh no, wait, give me half an hour, I need to fix this... If you want to get your feature into prod, just do it!
            --
            ### You don't need to wait for a PR review

            Note: It's not just the PR review and possibly approval, it's also suggestion for changes, asking for clarification etc... it all takes time. 
            --
            ### You do move faster

            Note: and as a result of that, I'm convinced that you do move faster as a team.
            --
            ### You get into the habit of not breaking things

            Note: Mentally, it's just different if you know that your code will go live immediately. You are way more careful, more sharp. And when the build is red, it's serious. We'd address it straight away.
            --
            ### Reviewing code changes is much easier

            Note: when you pull the code down to get the latest changes, it's much easier to review them. You're in your IDE, you're in the context of your code... many times I've actually pulled down the branch to review a PR to see the context in which the code runs.
            --
            ### Full commit history is retained

            Note: You can really follow the history of the codebase much more naturally. There are no merge commits... no squashes... 
            --
            ### Collective code ownership and knowledge

            Note: Everyone felt a lot more ownership over the code. You don't have the feeling of "someone else built this, I don't know what their thinking was... let me ask this person but they're not working today...". Everyone knew much more about the codebase, why things were the way they were etc.
            --
            ### The process optimises for team performance

            Note: instead of individual performance. TODO: why is this good?
            ---
            ## Convinced yet?
            ---
            ### How do you as a team start?

            Note: So do you fancy trying it out as a team?
            --
            ### Start slowly

            - small codebase
            - you have to have confidence in your tests
            - you have to pair-program

            Note: I wouldn't recommend going all in straight away. Maybe start with a new codebase or a small codebase.
            --
            ### Even if your team process and codebase is not there yet...

            Note: I know that most teams probably don't pair-program that much and most codebases don't have super reliable tests.
            --
            ### How about you start with...
            --
            ## Raise small PRs

            Note: Make your PRs a bit smaller... it doesn't have to be one feature per PR. Advantage of a small PR is that the review will be much quicker, you get it merged in quicker, releases are less risky...
            --
            ## Remove the mandatory PR approvals

            Note: I don't mean, just merge in all PRs as you want... but you could agree as a team that you ask for feedback if you want some... or you could just inform people, hey, I made this change, I'll merge it in now... or if it's a small change, just merge it in.
            --
            ## Agree to pair on a small thing and push a commit to `main`

            Note: just try it out with a small feature... maybe you'll enjoy pairing on something. Just push it to main.
            --
            ## Let all commits on main go to staging

            Note: As a first step you don't need to make all commits go to prod straight away but you could let them go to staging instead.
            --
          </script>
      </section>
    </div>
  </div>

  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,

      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
  </script>
</body>

</html>